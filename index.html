<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <meta http-equiv="Content-Security-Policy" content="media-src 'self' https://files.catbox.moe; font-src 'self' https://fonts.gstatic.com; connect-src 'self' https://fonts.googleapis.com;">

    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="manifest" href="manifest.json">
    <link rel="icon" href="data:;base64,iVBORw0KGgo=">

    <title>Neon Survivor</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        body { margin: 0; background-color: #050011; overflow: hidden; font-family: 'Press Start 2P', cursive; color: white; user-select: none; -webkit-tap-highlight-color: transparent; }
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #050011; }
        ::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }
        .font-smooth { font-family: 'Roboto', sans-serif; }
        #game-container { position: relative; width: 100vw; height: 100vh; filter: contrast(1.1) saturate(1.2); background: #050011; }
        canvas { display: block; width: 100%; height: 100%; }
        #hud { display: none; position: absolute; top: 20px; left: 20px; width: 350px; z-index: 10; pointer-events: none; text-transform: uppercase; font-family: 'Press Start 2P', cursive; }
        .hud-text { font-size: 10px; color: #ccc; margin-bottom: 5px; text-shadow: 2px 2px 0 #000; display: flex; justify-content: space-between; }
        .bar-wrap { width: 100%; height: 24px; background: #1a1a1a; border: 2px solid #333; margin-bottom: 15px; border-radius: 4px; overflow: hidden; box-shadow: 0 0 10px rgba(0,0,0,0.5); }
        #hpBar { width: 100%; height: 100%; background: linear-gradient(90deg, #c0392b, #e74c3c); box-shadow: 0 0 15px #e74c3c; transition: width 0.1s; }
        #xpBar { width: 0%; height: 100%; background: linear-gradient(90deg, #2980b9, #3498db); box-shadow: 0 0 15px #3498db; transition: width 0.1s; }
        #uiLvl { color: #f1c40f; text-shadow: 0 0 10px #f1c40f; }
        #uiTime { color: #fff; font-size: 16px; margin-top: 5px; display: block; text-align: right; font-family: 'Press Start 2P', cursive; }
        .timer-frozen { color: #e74c3c !important; text-shadow: 2px 0 #fff, -2px 0 #fff !important; animation: glitch 0.2s infinite !important; }
        #pause-indicator { display: none; position: absolute; top: 20px; right: 20px; color: yellow; z-index: 15; font-size: 12px; animation: flicker 2s infinite; font-family: 'Press Start 2P', cursive; }
        @media (max-width: 900px) and (orientation: landscape) {
            #hud { width: 40%; top: 10px; left: 10px; max-width: 250px; }
            .hud-text { font-size: 8px; }
            .bar-wrap { height: 16px !important; margin-bottom: 8px !important; border-width: 1px; }
            #uiTime { font-size: 12px !important; }
        }
        .modal-screen { display: none; position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(5, 5, 5, 0.95); backdrop-filter: blur(8px); flex-direction: column; justify-content: center; align-items: center; z-index: 20; }
        #startScreen { display: flex; z-index: 30; background: radial-gradient(circle at center, #1a0b2e 0%, #000000 100%); }
        #startScreen::before { content: ""; position: absolute; top: -50%; left: -50%; width: 200%; height: 200%; background: linear-gradient(rgba(0, 255, 255, 0.1) 1px, transparent 1px), linear-gradient(90deg, rgba(255, 0, 255, 0.1) 1px, transparent 1px); background-size: 100px 100px; transform: perspective(500px) rotateX(60deg); animation: moveGrid 10s linear infinite; pointer-events: none; z-index: -1; }
        .start-content { z-index: 10; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 40px; background: rgba(0, 0, 0, 0.8); border: 2px solid rgba(255, 255, 255, 0.1); border-radius: 20px; box-shadow: 0 0 50px rgba(0,0,0,0.8); }
        .title-neon { font-family: 'Press Start 2P', cursive; font-size: 50px; color: #fff; margin-bottom: 50px; text-align: center; line-height: 1.2; text-shadow: 0 0 10px #fff, 0 0 20px #0ff, 0 0 40px #0ff; animation: titleFloat 3s ease-in-out infinite; }
        input[type="text"] { background: transparent; border: none; border-bottom: 2px solid #555; padding: 15px; color: #f1c40f; font-family: 'Press Start 2P'; font-size: 18px; text-align: center; width: 300px; text-transform: uppercase; outline: none; transition: 0.3s; margin-bottom: 30px; letter-spacing: 2px; }
        input[type="text"]:focus { border-bottom-color: #f1c40f; box-shadow: 0 10px 20px -10px rgba(241, 196, 15, 0.3); transform: scale(1.05); }
        .btn-start { background: transparent; border: 3px solid #00ff00; color: #00ff00; padding: 20px 50px; font-family: 'Press Start 2P'; font-size: 20px; cursor: pointer; box-shadow: 0 0 15px rgba(0, 255, 0, 0.2); text-shadow: 0 0 10px #00ff00; animation: pulseCoin 0.8s infinite alternate; transition: 0.1s; touch-action: manipulation; }
        .btn-start:hover { background: #00ff00; color: #000; box-shadow: 0 0 40px #00ff00; animation: none; transform: scale(1.05); }
        .btn-rank { position: fixed; bottom: 30px; right: 30px; z-index: 40; width: 60px; height: 60px; background: rgba(0, 0, 0, 0.9); border: 2px solid #f1c40f; border-radius: 12px; color: #f1c40f; font-size: 24px; cursor: pointer; box-shadow: 0 0 15px rgba(241, 196, 15, 0.3); display: flex; justify-content: center; align-items: center; transition: 0.2s; font-family: 'Press Start 2P'; }
        .btn-rank:hover { background: #f1c40f; color: #000; box-shadow: 0 0 30px #f1c40f; transform: scale(1.1) rotate(5deg); }
        .leaderboard-container { width: 80%; max-width: 700px; max-height: 50vh; overflow-y: auto; border: 2px solid #444; background: #0a0a0a; margin: 20px 0; box-shadow: 0 0 30px rgba(0,0,0,0.8); }
        .lb-row { display: grid; grid-template-columns: 0.5fr 2fr 1.5fr 1fr; padding: 15px; border-bottom: 1px solid #222; align-items: center; font-size: 10px; transition: 0.2s; color: #aaa; touch-action: manipulation; }
        .lb-row:hover { background: #1a1a1a; color: #fff; border-left: 3px solid #f1c40f; }
        .lb-header { font-weight: bold; color: #f1c40f; background: #111; position: sticky; top: 0; z-index: 2; border-bottom: 2px solid #444; text-shadow: 0 0 5px rgba(241, 196, 15, 0.5); }
        .view-btn { background: #333; border: 1px solid #555; color: #ddd; padding: 6px 12px; cursor: pointer; font-size: 8px; font-family: 'Press Start 2P'; transition: 0.2s; }
        .view-btn:hover { background: #fff; color: #000; box-shadow: 0 0 10px #fff; }
        .btn-back { background: #c0392b; border: none; border-bottom: 4px solid #922b21; color: white; padding: 15px 30px; font-family: 'Press Start 2P'; font-size: 14px; cursor: pointer; margin-top: 20px; }
        .history-card { background: #181818; border-left: 4px solid #555; padding: 12px; border-radius: 4px; display: flex; flex-direction: column; gap: 6px; opacity: 0; animation: slideUp 0.3s forwards; }
        .history-card:hover { background: #222; transform: translateX(5px); }
        .hc-header { display: flex; justify-content: space-between; border-bottom: 1px solid #333; padding-bottom: 5px; font-size: 9px; color: #888; }
        .btn-close { position: absolute; top: 20px; right: 30px; background: transparent; border: 2px solid #e74c3c; color: #e74c3c; padding: 10px 20px; cursor: pointer; font-family: 'Press Start 2P'; font-size: 12px; transition: 0.2s; }
        .btn-close:hover { background: #e74c3c; color: #fff; }
        #detailsModal { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #050505; flex-direction: column; align-items: center; z-index: 50; overflow-y: auto; }
        .card-container { display: flex; gap: 30px; flex-wrap: wrap; justify-content: center; padding-top: 20px; }
        .card { width: 260px; padding: 30px; border-radius: 12px; cursor: pointer; text-align: center; border: 2px solid #333; background: #151515; position: relative; overflow: hidden; box-shadow: 0 10px 30px rgba(0,0,0,0.8); touch-action: manipulation; opacity: 0; animation: cardEnter 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards; transition: all 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94); }
        .card::after { content: ''; position: absolute; top: 0; left: -150%; width: 150%; height: 100%; background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent); transform: skewX(-20deg); transition: 0.5s; pointer-events: none; }
        .card:hover::after { left: 150%; transition: 0.7s; }
        .card h3 { font-family: 'Press Start 2P'; font-size: 12px; margin-bottom: 20px; color: #fff; min-height: 40px; display: flex; align-items: center; justify-content: center; text-transform: uppercase; text-shadow: 0 2px 4px rgba(0,0,0,0.8); line-height: 1.5; }
        .card p { font-family: 'Roboto', sans-serif; font-size: 14px; color: #aaa; line-height: 1.6; pointer-events: none; transition: color 0.2s; }
        .card:hover p { color: #fff; }
        .card.selected { animation: cardSelected 0.45s forwards cubic-bezier(0.175, 0.885, 0.32, 1.275) !important; z-index: 100; border-color: #fff !important; background: #fff !important; box-shadow: 0 0 60px #fff, inset 0 0 30px #fff !important; }
        .card.selected h3, .card.selected p { color: #000 !important; font-weight: bold; }
        .card.dimmed { opacity: 0.1; filter: blur(5px); transform: scale(0.9); pointer-events: none; transition: 0.4s; }
        @keyframes cardSelected {
            0% { transform: scale(1); }
            40% { transform: scale(1.05); }
            100% { transform: scale(1.4); opacity: 0; }
        }
        .card.common { border-bottom: 4px solid #95a5a6; }
        .card.common:hover { border-color: #bdc3c7; box-shadow: 0 0 30px rgba(189, 195, 199, 0.4); }
        .card.uncommon { border-bottom: 4px solid #2ecc71; }
        .card.uncommon:hover { border-color: #27ae60; box-shadow: 0 0 30px rgba(46, 204, 113, 0.5); }
        .card.epic { border-bottom: 4px solid #9b59b6; }
        .card.epic:hover { border-color: #8e44ad; box-shadow: 0 0 30px rgba(155, 89, 182, 0.6); }
        .card.legendary { border-bottom: 4px solid #f1c40f; background: linear-gradient(135deg, #151515, #1a1a0a); }
        .card.legendary:hover { border-color: #f39c12; box-shadow: 0 0 40px rgba(241, 196, 15, 0.8); transform: translateY(-12px) scale(1.1); }
        .card.legendary h3 { color: #f1c40f; text-shadow: 0 0 10px #f1c40f; }
        .btn-patch { position: fixed; bottom: 100px; right: 30px; z-index: 40; width: 60px; height: 60px; background: rgba(0, 0, 0, 0.9); border: 2px solid #00f3ff; border-radius: 12px; color: #00f3ff; font-size: 24px; cursor: pointer; box-shadow: 0 0 15px rgba(0, 243, 255, 0.3); display: flex; justify-content: center; align-items: center; transition: 0.2s; }
        .btn-patch:hover { background: #00f3ff; color: #000; box-shadow: 0 0 30px #00f3ff; transform: scale(1.1) rotate(-5deg); }
        #patchModal { display: none; z-index: 60; justify-content: center; align-items: center; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.8); backdrop-filter: blur(5px); }
        .patch-outer { position: relative; padding: 4px; background: #111; overflow: hidden; border-radius: 20px; animation: cardEnter 0.6s ease-out; width: 90%; max-width: 750px; margin: auto; }
        .patch-outer::before { content: ''; position: absolute; width: 150%; height: 150%; background: conic-gradient(#ff00ff, #00ffff, #ff00ff); top: -25%; left: -25%; animation: borderRotate 4s linear infinite; }
        .patch-container { position: relative; background: #0a0a0f; background-image: linear-gradient(rgba(0, 255, 255, 0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(255, 0, 255, 0.05) 1px, transparent 1px); background-size: 50px 50px; border-radius: 18px; padding: 40px; max-height: 80vh; overflow-y: auto; z-index: 2; border: 1px solid rgba(255, 255, 255, 0.1); }
        .patch-header { text-align: center; border-bottom: 1px solid rgba(0, 255, 255, 0.2); padding-bottom: 20px; margin-bottom: 30px; position: relative; text-shadow: 0 0 10px rgba(255, 0, 255, 0.5); }
        .patch-title { font-family: 'Press Start 2P', cursive; font-size: 20px; color: #fff; letter-spacing: 2px; line-height: 1.5; }
        .patch-date { font-family: 'Roboto'; color: #00f3ff; font-size: 10px; margin-top: 15px; display: block; letter-spacing: 2px; text-transform: uppercase; }
        .patch-section { margin-bottom: 35px; opacity: 0; animation: slideUp 0.5s forwards; }
        .patch-sec-title { font-family: 'Press Start 2P'; color: #ff00ff; font-size: 10px; margin-bottom: 15px; display: flex; align-items: center; gap: 10px; }
        .patch-sec-title::after { content:''; flex:1; height:1px; background: rgba(255,0,255,0.2); }
        .patch-list { list-style: none; padding-left: 20px; font-family: 'Roboto'; font-size: 14px; color: #bbb; line-height: 1.8; }
        .patch-list li { margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid rgba(255,255,255,0.05); }
        .patch-list li::before { content: '¬ª'; color: #00ffff; margin-right: 15px; font-weight: bold; }
        .tag-new { font-family: 'Press Start 2P'; font-size: 8px; margin-right: 12px; background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00, #00ffff, #0000ff, #ff00ff, #ff0000); background-size: 400%; background-clip: text; -webkit-background-clip: text; color: transparent; animation: rainbowFlow 3s linear infinite; font-weight: bold; }
        .patch-close { width: 100%; padding: 20px; background: #111; border: 2px solid #00ff00; color: #00ff00; font-family: 'Press Start 2P'; cursor: pointer; transition: 0.2s; margin-top: 20px; text-shadow: 0 0 5px #00ff00; }
        .patch-close:hover { background: #00ff00; color: #000; box-shadow: 0 0 30px #00ff00; }
        @keyframes borderRotate { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        @keyframes scanLine { 0% { transform: translateX(-100%); } 100% { transform: translateX(100%); } }
        @keyframes rainbowFlow { 0% { background-position: 0%; } 100% { background-position: 400%; } }
        @keyframes textGlitch { 0% { transform: skew(0deg); } 20% { transform: skew(-2deg); } 40% { transform: skew(2deg); } 60% { transform: skew(0deg); opacity: 1; } 61% { opacity: 0.8; } 62% { opacity: 1; } 100% { transform: skew(0deg); } }
        @keyframes panelGlitch { 0% { border-color: #ff00ff; } 98% { border-color: #ff00ff; box-shadow: 0 0 20px rgba(255, 0, 255, 0.2); } 99% { border-color: #fff; box-shadow: 0 0 50px #fff; } 100% { border-color: #ff00ff; } }
        @keyframes moveGrid { 0% { background-position: 0 0; } 100% { background-position: 0 100px; } }
        @keyframes flicker { 0%,100% { opacity:1; } 50% { opacity:0.5; } }
        @keyframes titleFloat { 0%,100% { transform: translateY(0); text-shadow: 0 0 10px #fff, 0 0 20px #0ff; } 50% { transform: translateY(-5px); text-shadow: 0 0 15px #fff, 0 0 30px #0ff; } }
        @keyframes pulseCoin { 0% { transform: scale(1); opacity: 1; } 100% { transform: scale(0.95); opacity: 0.8; } }
        @keyframes cardEnter { from { opacity: 0; transform: translateY(50px) scale(0.8); } to { opacity: 1; transform: translateY(0) scale(1); } }
        @keyframes slideUp { from { opacity:0; transform: translateY(20px); } to { opacity:1; transform: translateY(0); } }
        @keyframes shake { 0% { transform: translate(0, 0); } 25% { transform: translate(-3px, 3px); } 50% { transform: translate(3px, -3px); } 75% { transform: translate(-3px, -3px); } 100% { transform: translate(0, 0); } }
        .shaking { animation: shake 0.2s cubic-bezier(.36,.07,.19,.97) both; filter: chromatic-aberration 1; }
        #damage-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, transparent 60%, rgba(255, 0, 0, 0.0) 100%); pointer-events: none; transition: background 0.1s; z-index: 5; }
        .hurt-effect { background: radial-gradient(circle, transparent 40%, rgba(255, 0, 0, 0.4) 100%) !important; }
        .glitch-canvas { animation: glitch 0.2s linear; }
        @keyframes glitch { 0% { transform: translate(2px,0); } 25% { transform: translate(-2px,2px); } 50% { transform: translate(-2px,-2px); } 75% { transform: translate(2px,2px); } 100% { transform: translate(0); } }
    </style>
</head>
<body>

    <div id="damage-overlay"></div>
    <div id="pause-indicator">PAUSADO [ESC]</div>
    <div id="game-container"><canvas id="gameCanvas"></canvas></div>

    <div id="startScreen" class="modal-screen" style="display: flex;">
        <div class="start-content">
            <div class="title-neon">NEON<br>SURVIVOR</div>
            <div class="input-group">
                <input type="text" id="playerName" placeholder="CODENAME" maxlength="10" autocomplete="off">
            </div>
            <button class="btn-start" onclick="startGame()">START</button>
            <p style="margin-top: 30px; color: #888; font-size: 10px; font-family: 'Roboto'; letter-spacing: 1px;">WASD / TOUCH</p>
        </div>
        
        <button class="btn-patch" onclick="openPatchNotes()" title="Patch Notes">üì∞</button>
        <button class="btn-rank" onclick="openLeaderboard()" title="Ranking">üèÜ</button>
    </div>

    <div id="patchModal">
        <div class="patch-outer">
            <div class="patch-container">
                <div class="patch-header">
                    <h2 class="patch-title">ANGEL UPDATE</h2>
                    <span class="patch-date">v0.2.1 // 15.12.2025</span>
                </div>
                
                <div class="patch-section" style="animation-delay: 0.1s;">
                    <h3 class="patch-sec-title">NOVAS DIRETRIZES</h3>
                    <ul class="patch-list">
                        <li><span class="tag-new">[NEW]</span> <b>5 NOVAS AMEA√áAS</b> foram detectadas no sistema. Adapte sua estrat√©gia de combate.</li>
                        <li><b>REVIS√ÉO GERAL DE VISUAIS:</b> Todos os agentes inimigos receberam uma atualiza√ß√£o visual para maior clareza t√°tica.</li>
                    </ul>
                </div>

                <div class="patch-section" style="animation-delay: 0.2s;">
                    <h3 class="patch-sec-title" style="color: #f1c40f;">ESTAT√çSTICAS & N√öCLEO</h3>
                    <ul class="patch-list">
                        <li><b>ESTABILIDADE DE MOVIMENTO:</b> Corrigido um bug de input que travava o movimento do piloto ap√≥s usar a manobra de esquiva [ESPA√áO].</li>
                        <li><b>REBALANCEAMENTO DE ENTIDADE:</b> Amea√ßa <span id="glitch-boss-name" style="color: #e74c3c; font-family: 'Press Start 2P';">NÃ∑EÃ¥OÃµNÃ∏ Ã¥AÃ∂NÃ∏GÃ¥EÃ¥LÃ¥</span> teve seu dano base reduzido e seu primeiro surgimento foi ajustado para 5 minutos.</li>
                    </ul>
                </div>

                <button class="patch-close" onclick="closePatchNotes()">CONFIRM PROTOCOL</button>
            </div>
        </div>
    </div>

    <div id="hud">
        <div class="hud-text"><span>SHIELD</span></div>
        <div class="bar-wrap"><div id="hpBar"></div></div>
        <div class="hud-text"><span>DATA - LVL <span id="uiLvl">1</span></span></div>
        <div class="bar-wrap"><div id="xpBar"></div></div>
        <div class="hud-text"><span>FRAGS: <span id="uiKills">0</span></span><span id="uiTime">00:00</span></div>
    </div>

    <div id="upgradeScreen" class="modal-screen">
        <h2 style="color: #f1c40f; margin-bottom: 40px; text-shadow: 0 0 10px gold;">SYSTEM UPGRADE</h2>
        <div class="card-container" id="cardsBox"></div>
    </div>

    <div id="gameOverScreen" class="modal-screen">
        <h1 style="color: #e74c3c; font-size: 40px; margin-bottom: 20px; text-shadow: 0 0 20px #e74c3c;">SYSTEM FAILURE</h1>
        <div class="leaderboard-container" id="lbListGO"></div>
        <button class="btn-start" onclick="rebootGame()">REBOOT</button>
    </div>

    <div id="leaderboardScreen" class="modal-screen">
        <h1 style="color: #f1c40f; font-size: 30px; margin-bottom: 20px; text-shadow: 0 0 10px #f1c40f;">DATABASE</h1>
        <div class="leaderboard-container" id="lbListMain"></div>
        <button class="btn-back" onclick="closeLeaderboard()">BACK</button>
    </div>

    <div id="detailsModal">
        <button class="btn-close" onclick="closeDetails()">X CLOSE</button>
        <div id="detailsHeader" style="width:100%; text-align:center; padding: 20px; background:#111;">
            <h1 id="detailName" style="color: #3498db; font-size: 24px;">PLAYER</h1>
            <p style="font-family: 'Roboto'; color: #888; margin-top: 5px; font-size: 12px;">SYSTEM LOGS</p>
        </div>
        <div id="detailsGrid" style="width:90%; max-width:800px; display:grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap:15px; padding:20px; overflow-y:auto; max-height:70vh;"></div>
    </div>

    <script src="upgrades.js"></script>
    <script src="mobile.js"></script>
    <script src="sfx.js"></script>
    <script src="drops.js"></script>
    <script src="mechanics.js"></script>
    <script src="enemy.js"></script>
    <script src="events.js"></script>

<script>
    if (typeof upgradePool === 'undefined') alert("ERRO: 'upgrades.js' ausente.");

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const world = { width: 4000, height: 4000 };
    const camera = { x: 0, y: 0 };
    
    let gameState = 'START';
    let frames = 0, seconds = 0, difficulty = 1;
    let currentPlayerName = "Unknown";
    let activeLevelUpSound = null;
    let screenShake = 0;
    
    const particles = [], bullets = [], gems = [], floatingTexts = [];
    const shockwaves = [], backgroundParticles = [];
    const keys = {};

    for(let i=0; i<150; i++) {
        let type = 'star';
        let size = Math.random()*2;
        let color = 'rgba(255, 255, 255, 0.5)';
        if(Math.random() < 0.05) {
            type = 'planet';
            size = 10 + Math.random() * 20;
            const r = 50 + Math.random() * 100;
            const g = 50 + Math.random() * 100;
            const b = 150 + Math.random() * 100;
            color = `rgba(${r}, ${g}, ${b}, 0.2)`;
        }
        backgroundParticles.push({
            x: Math.random() * world.width,
            y: Math.random() * world.height,
            size: size,
            speed: Math.random() * 0.5,
            type: type,
            color: color,
            isPlanet: type === 'planet' 
        });
    }

    const player = {
        x: world.width / 2, y: world.height / 2, size: 15, color: '#0ff',
        speed: 5, maxHp: 100, hp: 100, regenRate: 0, 
        invulnDuration: 30, invulnTimer: 0, lifesteal: 0, lifestealChance: 0, healOnLevelUp: 0,
        damage: 20, atkSpeed: 40, cooldown: 0,
        projectiles: 1, bulletSpeed: 11, bulletSize: 4, knockback: 1.5,
        critChance: 0.05, critMult: 2, magnetRadius: 150, xpMultiplier: 1,
        dodge: 0, thorns: 0,
        xp: 0, nextLevelXp: 15, level: 1, kills: 0, history: [],
        angle: 0, trail: []
    };

    function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
    window.addEventListener('resize', resize); resize();

    const savedName = localStorage.getItem('last_player_name');
    if (savedName) document.getElementById('playerName').value = savedName;

    const currentData = JSON.parse(localStorage.getItem('neon_survivor_lb')) || [];
    if (currentData.length === 0) {
        const dummies = [{name:"NEO",seconds:300,timeStr:"05:00",kills:500,history:[]},{name:"CPU",seconds:120,timeStr:"02:00",kills:150,history:[]}];
        localStorage.setItem('neon_survivor_lb', JSON.stringify(dummies));
    }

    window.addEventListener('keydown', e => { 
        keys[e.key] = true; 
        if(e.key === 'Enter' && gameState === 'START') startGame(); 
        if(e.key === 'Escape') togglePause();
        if(e.key === '/' && gameState === 'PLAYING') seconds = 290; 
        if(e.key === '>' && gameState === 'PLAYING' && bossSystem.active) bossSystem.hp = 0;
    });
    window.addEventListener('keyup', e => keys[e.key] = false);

    let glitchInterval = null;
    function startBossNameGlitch() {
        const bossNameEl = document.getElementById('glitch-boss-name');
        if (!bossNameEl || glitchInterval) return;
        const originalText = "NÃ∑EÃ¥OÃµNÃ∏ Ã¥AÃ∂NÃ∏GÃ¥EÃ¥LÃ¥";
        glitchInterval = setInterval(() => {
            let glitchText = "";
            for (let i = 0; i < originalText.length; i++) {
                if (originalText[i] === ' ') {
                    glitchText += ' ';
                } else {
                    glitchText += String.fromCharCode(33 + Math.floor(Math.random() * 94));
                }
            }
            bossNameEl.textContent = glitchText;
        }, 80);
    }

    function stopBossNameGlitch() {
        if(glitchInterval) {
            clearInterval(glitchInterval);
            glitchInterval = null;
        }
        const bossNameEl = document.getElementById('glitch-boss-name');
        if (bossNameEl) bossNameEl.textContent = "NÃ∑EÃ¥OÃµNÃ∏ Ã¥AÃ∂NÃ∏GÃ¥EÃ¥LÃ¥";
    }
    
    function openPatchNotes() { 
        document.getElementById('patchModal').style.display = 'flex';
        startBossNameGlitch();
    }
    function closePatchNotes() { 
        document.getElementById('patchModal').style.display = 'none';
        stopBossNameGlitch();
    }
    
    window.addEventListener('load', () => {
        if (sessionStorage.getItem('isRebooting') === 'true') {
            sessionStorage.removeItem('isRebooting');
        } else {
            openPatchNotes();
        }
    });

    function rebootGame() {
        sessionStorage.setItem('isRebooting', 'true');
        location.reload();
    }

    function startGame() {
        const input = document.getElementById('playerName');
        if (input.value.trim() === "") { alert("CODINOME NECESS√ÅRIO"); return; }
        
        try {
            if (document.documentElement.requestFullscreen) document.documentElement.requestFullscreen();
            else if (document.documentElement.webkitRequestFullscreen) document.documentElement.webkitRequestFullscreen();
        } catch(e){}

        if (typeof sfx !== 'undefined') {
            sfx.unlockAudio();
        }
        
        currentPlayerName = input.value.trim().toUpperCase();
        localStorage.setItem('last_player_name', currentPlayerName);
        document.getElementById('startScreen').style.display = 'none';
        document.getElementById('hud').style.display = 'block';
        gameState = 'PLAYING';
    }

    function togglePause() {
        if (gameState === 'PLAYING') { 
            gameState = 'PAUSED'; 
            document.getElementById('pause-indicator').style.display = 'block'; 
            canvas.style.filter = 'grayscale(100%) blur(2px)'; 
            sfx.stopMusic(); 
        } 
        else if (gameState === 'PAUSED') { 
            gameState = 'PLAYING'; 
            document.getElementById('pause-indicator').style.display = 'none'; 
            canvas.style.filter = 'none';
            let track = 0;
            if (difficulty >= 4) track = 2;
            else if (difficulty >= 2) track = 1;
            sfx.playTrack(track);
        }
    }

    function openLeaderboard() { document.getElementById('startScreen').style.display = 'none'; document.getElementById('leaderboardScreen').style.display = 'flex'; renderLeaderboard('lbListMain'); }
    function closeLeaderboard() { document.getElementById('leaderboardScreen').style.display = 'none'; document.getElementById('startScreen').style.display = 'flex'; }

    function update() {
        if (gameState !== 'PLAYING') return;
        frames++;
        if (frames % 60 === 0) {
            if (!eventSystem.isTimerFrozen) {
                seconds++; difficulty += 0.01;
                document.getElementById('uiTime').classList.remove('timer-frozen');
            } else {
                document.getElementById('uiTime').classList.add('timer-frozen');
            }
            
            document.getElementById('uiTime').innerText = formatTime(seconds);
            
            if (player.regenRate > 0) player.hp = Math.min(player.maxHp, player.hp + player.regenRate);
            updateHUD();

            checkEvents(seconds);

            if (!eventSystem.bossEncounter) {
                if (difficulty >= 4 && sfx.currentTrackId !== 2) sfx.playTrack(2);
                else if (difficulty >= 2 && sfx.currentTrackId !== 1) sfx.playTrack(1);
            }
        }

        if (eventSystem.bossEncounter) {
            if(eventSystem.lockedCamera) {
                camera.x = eventSystem.lockedCamera.x;
                camera.y = eventSystem.lockedCamera.y;
            }
        } else {
            const tx = player.x - canvas.width / 2; const ty = player.y - canvas.height / 2;
            camera.x += (tx - camera.x) * 0.08; camera.y += (ty - camera.y) * 0.08;
            camera.x = Math.max(0, Math.min(camera.x, world.width - canvas.width));
            camera.y = Math.max(0, Math.min(camera.y, world.height - canvas.height));
        }
        
        if (screenShake > 0) {
            camera.x += (Math.random() - 0.5) * screenShake;
            camera.y += (Math.random() - 0.5) * screenShake;
            screenShake *= 0.9;
            if (screenShake < 0.5) screenShake = 0;
        }

        updatePlayer(); 
        updateMechanics(player); 
        updateBoss(); 
        enemySystem.spawnController(difficulty, player, canvas); 
        enemySystem.update(player); 
        updateBullets(); 
        updateGems(); 
        updateDrops(player); 
        updateParticles(); 
        updateShockwaves(); 
        updateText();
    }

    function updatePlayer() {
        player.angle += 0.05; 
        for(let i = player.trail.length - 1; i >= 0; i--) { 
            player.trail[i].life--; 
            if (player.trail[i].life <= 0) player.trail.splice(i, 1); 
        }

        if (eventSystem.bossEncounter) {
            player.x = Math.max(camera.x + player.size, Math.min(camera.x + canvas.width - player.size, player.x));
            player.y = Math.max(camera.y + player.size, Math.min(camera.y + canvas.height - player.size, player.y));
        } else {
            player.x = Math.max(player.size, Math.min(world.width - player.size, player.x));
            player.y = Math.max(player.size, Math.min(world.height - player.size, player.y));
        }

        if (player.invulnTimer > 0) player.invulnTimer--;

        if (player.cooldown > 0) player.cooldown--;
        else if (enemySystem.enemies.length > 0 || bossSystem.active) {
            let t = enemySystem.getClosest(player);
            if (bossSystem.active && (!t || Math.hypot(player.x - bossSystem.x, player.y - bossSystem.y) < Math.hypot(player.x - t.x, player.y - t.y))) {
                t = { x: bossSystem.x, y: bossSystem.y }; 
            }
            if (t) { shoot(t); player.cooldown = player.atkSpeed; }
        }
    }

    function shoot(target) {
        const a = Math.atan2(target.y - player.y, target.x - player.x);
        const count = Math.floor(player.projectiles); const spread = count > 1 ? 0.25 : 0; 
        for(let i = 0; i < count; i++) {
            const fa = a + (count > 1 ? (i - (count-1)/2) * spread : 0);
            bullets.push({x: player.x, y: player.y, vx: Math.cos(fa) * player.bulletSpeed, vy: Math.sin(fa) * player.bulletSpeed, life: 200, damage: player.damage, isCrit: Math.random() < player.critChance, knockback: player.knockback, size: player.bulletSize});
        }
        sfx.shoot();
    }

    function takeDamage(val) { 
        if (player.dodge && Math.random() < player.dodge) { spawnPopText(player.x, player.y, "DODGE", true); return; }
        player.hp -= val; player.invulnTimer = player.invulnDuration; updateHUD(); triggerDamageEffect(); 
        sfx.hit();
        if (player.hp <= 0) triggerGameOver(); 
    }

    function updateBullets() {
        for (let i = bullets.length - 1; i >= 0; i--) {
            let b = bullets[i]; b.x += b.vx; b.y += b.vy; b.life--;
            
            if (b.isEnemy) {
                if (Math.hypot(player.x - b.x, player.y - b.y) < player.size + b.size) {
                    takeDamage(b.damage); bullets.splice(i, 1);
                } else if (b.life <= 0) bullets.splice(i, 1);
                continue;
            }

            if(frames % 2 === 0) particles.push({x:b.x, y:b.y, vx:0, vy:0, life:10, color: '#f1c40f', size:2, isStatic:true});
            if (b.life <= 0) { bullets.splice(i, 1); continue; }
            
            let hit = false;
            
            if (bossSystem.active && bossSystem.invulnTimer <= 0 && Math.hypot(b.x - bossSystem.x, b.y - bossSystem.y) < bossSystem.width * 0.5) {
                let dmg = b.isCrit ? b.damage * player.critMult : b.damage; 
                bossSystem.hp -= dmg; bossSystem.flash = 5;
                spawnPopText(bossSystem.x, bossSystem.y + 50, Math.floor(dmg), b.isCrit);
                spawnParticles(b.x, b.y, '#fff', 3);
                hit = true;
            } else {
                for (let j = enemySystem.enemies.length - 1; j >= 0; j--) {
                    let e = enemySystem.enemies[j];
                    if (e.type === 'bastion' && Math.abs(b.x - e.x) < e.size && Math.abs(b.y - e.y) < e.size) {
                        hit = true; 
                        break; 
                    }
                    if (Math.hypot(b.x - e.x, b.y - e.y) < e.size + b.size) {
                        let dmg = b.isCrit ? b.damage * player.critMult : b.damage; e.hp -= dmg; e.flashTimer = 5;
                        if (e.type !== 'bastion') {
                            e.x += b.vx * (b.knockback * 0.5); 
                            e.y += b.vy * (b.knockback * 0.5);
                        }
                        spawnPopText(e.x, e.y, Math.floor(dmg), b.isCrit); 
                        spawnParticles(e.x, e.y, e.color, 3);
                        if (e.hp <= 0) { enemySystem.handleDeath(e, j); sfx.explosion(); } else { sfx.hit(); }
                        hit = true; break; 
                    }
                }
            }
            if (hit) bullets.splice(i, 1);
        }
    }

    function killEnemy(e, index) {
        createGem(e.x, e.y, e.xpVal); 
        trySpawnDrop(e.x, e.y);
        spawnParticles(e.x, e.y, e.color, 8); 
        player.kills++; 
        if (player.lifestealChance && Math.random() < player.lifestealChance) player.hp = Math.min(player.maxHp, player.hp + 1);
        if (player.lifesteal > 0) player.hp = Math.min(player.maxHp, player.hp + player.lifesteal);
        if (index !== undefined && index > -1) enemySystem.enemies.splice(index, 1);
        updateHUD();
    }

    function createGem(x, y, val) { gems.push({ x, y, val, size: 4 }); }
    function updateGems() {
        for (let i = gems.length - 1; i >= 0; i--) {
            let g = gems[i]; const d = Math.hypot(player.x - g.x, player.y - g.y);
            if (d < player.magnetRadius) { g.x += (player.x - g.x) * 0.15; g.y += (player.y - g.y) * 0.15; }
            if (d < player.size + g.size) { 
                player.xp += g.val * player.xpMultiplier; gems.splice(i, 1); checkLevelUp(); 
                sfx.collect();
            }
        }
        updateHUD();
    }

    function spawnParticles(x, y, c, n) { for(let i=0; i<n; i++) particles.push({x,y,color:c, vx:(Math.random()-.5)*8, vy:(Math.random()-.5)*8, life:30+Math.random()*20, size:Math.random()*4}); }
    function spawnShockwave(x, y, color) { shockwaves.push({x, y, radius: 10, opacity: 1, color: color}); }
    function updateParticles() { for (let i = particles.length-1; i>=0; i--) { let p = particles[i]; if(!p.isStatic){p.x+=p.vx; p.y+=p.vy;} p.life--; p.size *= 0.92; if(p.life<=0) particles.splice(i,1); } }
    function updateShockwaves() { for (let i = shockwaves.length-1; i>=0; i--) { let s = shockwaves[i]; s.radius += 2; s.opacity -= 0.05; if(s.opacity <= 0) shockwaves.splice(i, 1); } }
    function spawnPopText(x, y, t, c) { floatingTexts.push({x, y, text:t, life:40, color:c?'#f1c40f':'#fff', vy:-1.5}); }
    function updateText() { for(let i = floatingTexts.length-1; i>=0; i--) { let t = floatingTexts[i]; t.y += t.vy; t.vy += 0.05; t.life--; if(t.life<=0) floatingTexts.splice(i,1); } }
    
    function triggerDamageEffect() { canvas.classList.add('glitch-canvas'); setTimeout(() => canvas.classList.remove('glitch-canvas'), 200); const o = document.getElementById('damage-overlay'); o.classList.add('hurt-effect'); setTimeout(() => o.classList.remove('hurt-effect'), 200); }

    function triggerGameOver() { 
        gameState = 'GAMEOVER'; 
        sfx.gameOver();
        saveScore(); 
        renderLeaderboard('lbListGO'); 
        document.getElementById('gameOverScreen').style.display = 'flex'; 
    }
    
    function saveScore() {
        let lb = JSON.parse(localStorage.getItem('neon_survivor_lb')) || [];
        const existingIndex = lb.findIndex(u => u.name === currentPlayerName);
        const newData = { name: currentPlayerName, seconds: seconds, timeStr: formatTime(seconds), kills: player.kills, level: player.level, history: player.history };
        if (existingIndex !== -1) { if (seconds > lb[existingIndex].seconds) lb[existingIndex] = newData; } else { lb.push(newData); }
        lb.sort((a, b) => b.seconds - a.seconds); if(lb.length > 50) lb = lb.slice(0, 50);
        localStorage.setItem('neon_survivor_lb', JSON.stringify(lb));
    }
    function renderLeaderboard(elementId) {
        const lb = JSON.parse(localStorage.getItem('neon_survivor_lb')) || [];
        const container = document.getElementById(elementId);
        container.innerHTML = `<div class="lb-row lb-header"><span>#</span><span>AGENT</span><span>STATS</span><span>LOGS</span></div>`;
        lb.forEach((entry, idx) => {
            const row = document.createElement('div'); row.className = 'lb-row';
            if (entry.name === currentPlayerName) row.style.color = '#f1c40f';
            const safeName = document.createElement('span'); safeName.className = 'lb-name'; safeName.innerText = entry.name;
            row.innerHTML = `<span class="lb-rank">${idx+1}</span>`; 
            row.appendChild(safeName); 
            const stats = document.createElement('span'); stats.innerHTML = `${entry.timeStr} / ${entry.kills}K`; row.appendChild(stats);
            const btnDiv = document.createElement('div'); const btn = document.createElement('button'); btn.className = 'view-btn'; btn.innerText = 'ACCESS'; btn.onclick = (e) => { e.stopPropagation(); showDetails(entry); };
            btnDiv.appendChild(btn); row.appendChild(btnDiv); container.appendChild(row);
        });
    }
    function showDetails(entry) { document.getElementById('detailsModal').style.display = 'flex'; document.getElementById('detailName').innerText = entry.name; const grid = document.getElementById('detailsGrid'); grid.innerHTML = ''; if (!entry.history || entry.history.length === 0) { grid.innerHTML = '<p style="color:#666; width:100%; text-align:center;">NO DATA LOGGED.</p>'; return; } entry.history.forEach((upg, i) => { const el = document.createElement('div'); el.className = `history-card ${upg.type}`; el.style.animationDelay = (i * 0.03) + 's'; let icon = upg.type === 'def' ? 'üõ°Ô∏è' : (upg.type === 'util' ? '‚ö°' : '‚öîÔ∏è'); el.innerHTML = `<div class="hc-header"><span class="hc-title">${upg.type.toUpperCase()}</span><span class="hc-icon">${icon}</span></div><strong style="color:white; font-size:11px;">${upg.title}</strong><div class="hc-desc">${upg.desc}</div>`; grid.appendChild(el); }); }
    function closeDetails() { document.getElementById('detailsModal').style.display = 'none'; }

    function checkLevelUp() { 
        if (player.xp >= player.nextLevelXp) { 
            player.level++; player.xp -= player.nextLevelXp; player.nextLevelXp = Math.floor(player.nextLevelXp * 1.3); if(player.healOnLevelUp > 0) player.hp = Math.min(player.maxHp, player.hp + player.healOnLevelUp); document.getElementById('uiLvl').innerText = player.level; 
            if(activeLevelUpSound) activeLevelUpSound(); 
            activeLevelUpSound = sfx.levelUp(); 
            toggleUpgradeScreen(true); 
        } 
    }
    function toggleUpgradeScreen(show) { const el = document.getElementById('upgradeScreen'); if(show) { gameState = 'LEVELUP'; el.style.display = 'flex'; generateCards(); } else { el.style.display = 'none'; gameState = 'PLAYING'; } }
    
    function generateCards() {
        const box = document.getElementById('cardsBox'); box.innerHTML = '';
        let pool = [...upgradePool]; 
        for(let i=0; i<3; i++) {
            if(pool.length === 0) break;
            const r = Math.floor(Math.random() * pool.length); const opt = pool[r];
            const card = document.createElement('div'); 
            let rarityClass = opt.rarity || 'common';
            card.className = `card ${opt.type} ${rarityClass}`;
            card.style.animationDelay = (i * 0.15) + 's';
            let icon = opt.type === 'def' ? 'üõ°Ô∏è' : (opt.type === 'util' ? '‚ö°' : '‚öîÔ∏è');
            card.innerHTML = `<h3>${icon} ${opt.title}</h3><p>${opt.desc}</p>`;
            card.onclick = () => {
                const allCards = box.querySelectorAll('.card');
                allCards.forEach(c => { c.onclick = null; if(c !== card) c.classList.add('dimmed'); });
                if(activeLevelUpSound) { activeLevelUpSound(); activeLevelUpSound = null; }
                sfx.collect(); 
                card.classList.add('selected');
                setTimeout(() => {
                    toggleUpgradeScreen(false);
                    requestAnimationFrame(() => {
                         opt.apply(player); 
                         player.history.push({ title: opt.title, type: opt.type, desc: opt.desc });
                         triggerUpgradeFX(opt.type);
                         gameState = 'PLAYING'; 
                    });
                }, 450); 
            };
            box.appendChild(card);
        }
    }

    function triggerUpgradeFX(type) {
        screenShake = 15;
        let color = '#fff'; let msg = "UPGRADE!";
        if (type === 'atk') { color = '#e74c3c'; msg = "POWER UP!"; }
        if (type === 'def') { color = '#2ecc71'; msg = "ARMOR UP!"; }
        if (type === 'util') { color = '#f1c40f'; msg = "SYSTEM UP!"; }
        spawnShockwave(player.x, player.y, color);
        shockwaves[shockwaves.length-1].radius = 1; 
        for(let i=0; i<30; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 2 + Math.random() * 5;
            particles.push({x: player.x, y: player.y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, color: color, size: 3 + Math.random() * 3, life: 60});
        }
        spawnPopText(player.x, player.y - 40, msg, true);
    }

    function formatTime(s) { return `${Math.floor(s/60).toString().padStart(2,'0')}:${(s%60).toString().padStart(2,'0')}`; }
    function updateHUD() { document.getElementById('hpBar').style.width = Math.max(0, (player.hp / player.maxHp) * 100) + '%'; document.getElementById('xpBar').style.width = Math.min(100, (player.xp / player.nextLevelXp) * 100) + '%'; document.getElementById('uiKills').innerText = player.kills; }
    
    function drawGrid() {
        ctx.lineWidth = 1; 
        ctx.beginPath();
        const gridSize = 60; 
        const sx = Math.floor(camera.x / gridSize) * gridSize; 
        const sy = Math.floor(camera.y / gridSize) * gridSize;
        
        for (let x = sx; x < sx + canvas.width + gridSize; x += gridSize) { 
            ctx.strokeStyle = (x === 0 || x === world.width) ? '#ff0055' : 'rgba(0, 255, 255, 0.1)'; 
            ctx.moveTo(x, sy); ctx.lineTo(x, sy + canvas.height + gridSize); 
        }
        for (let y = sy; y < sy + canvas.height + gridSize; y += gridSize) { 
            ctx.strokeStyle = (y === 0 || y === world.height) ? '#ff0055' : 'rgba(0, 255, 255, 0.1)'; 
            ctx.moveTo(sx, y); ctx.lineTo(sx + canvas.width + gridSize, y); 
        }
        ctx.stroke();
        
        ctx.strokeStyle = '#ff0055'; ctx.lineWidth = 5; ctx.strokeRect(0,0,world.width, world.height);
    }

    function draw() {
        const t = eventSystem.transitionProgress;
        const r = Math.floor(5 * (1-t));
        const g = 0;
        const b = Math.floor(17 * (1-t));
        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
        
        ctx.fillRect(0,0,canvas.width, canvas.height);
        ctx.save(); ctx.translate(-camera.x, -camera.y);
        
        drawGrid();

        backgroundParticles.forEach(p => { 
            if (eventSystem.bossEncounter) {
                if (p.isPlanet) {
                    p.y += (p.speed * (1 + eventSystem.scrollSpeed)) + eventSystem.scrollSpeed;
                    if(p.y > camera.y + canvas.height + 50) p.y = camera.y - 50;
                    if(p.x < camera.x) p.x += canvas.width;
                    if(p.x > camera.x + canvas.width) p.x -= canvas.width;

                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = eventSystem.transitionProgress;
                    ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
                } else {
                    p.y += (p.speed * (1 + eventSystem.scrollSpeed)) + eventSystem.scrollSpeed;
                    if(p.y > world.height + camera.y) p.y = camera.y - 50; 
                    if(p.x < camera.x) p.x += canvas.width;
                    if(p.x > camera.x + canvas.width) p.x -= canvas.width;

                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = 0.5;
                    ctx.fillRect(p.x, p.y, 2, p.size * (eventSystem.scrollSpeed + 2));
                }
            } else {
                if (!p.isPlanet) {
                    p.x += Math.cos(frames*0.01 + p.size); 
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = 0.2;
                    ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
                }
            }
        });
        ctx.globalAlpha = 1;

        shockwaves.forEach(s => { ctx.lineWidth = 2; ctx.strokeStyle = s.color; ctx.globalAlpha = s.opacity; ctx.beginPath(); ctx.arc(s.x, s.y, s.radius, 0, Math.PI*2); ctx.stroke(); ctx.globalAlpha = 1; });
        gems.forEach(g => { ctx.shadowBlur=10; ctx.shadowColor='#3498db'; ctx.fillStyle='#3498db'; ctx.beginPath(); ctx.arc(g.x, g.y, g.size + Math.sin(frames*0.1), 0, Math.PI*2); ctx.fill(); ctx.shadowBlur=0; });
        particles.forEach(p => { ctx.fillStyle=p.color; ctx.globalAlpha=p.life/30; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha=1; });
        
        enemySystem.draw(ctx, player);

        drawDrops(ctx);
        drawBoss(ctx);
        
        ctx.strokeStyle = player.color; ctx.lineWidth = 2; ctx.globalAlpha = 0.3; ctx.beginPath();
        if(player.trail.length > 1) { 
            if(typeof mechSystem !== 'undefined' && mechSystem.dash.active) {
                player.trail.forEach(t => {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)'; ctx.shadowBlur = 15; ctx.shadowColor = '#fff';
                    ctx.beginPath(); ctx.arc(t.x, t.y, player.size, 0, Math.PI*2); ctx.fill();
                });
            } else {
                ctx.moveTo(player.trail[0].x, player.trail[0].y); for(let i=1; i<player.trail.length; i++) ctx.lineTo(player.trail[i].x, player.trail[i].y); ctx.stroke();
            }
        }
        ctx.globalAlpha = 1;

        ctx.save(); ctx.translate(player.x, player.y);
        
        if(typeof mechSystem !== 'undefined' && mechSystem.dash.active) {
            ctx.shadowBlur = 40; ctx.shadowColor = '#fff'; ctx.fillStyle = '#fff';
        } else {
            ctx.shadowBlur = 20; ctx.shadowColor = player.color; ctx.fillStyle = player.color;
            if(player.invulnTimer > 0 && Math.floor(frames/5)%2===0) ctx.globalAlpha = 0.5;
        }

        ctx.beginPath(); ctx.arc(0, 0, 6, 0, Math.PI*2); ctx.fill();
        ctx.rotate(player.angle); ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.beginPath(); ctx.rect(-10, -10, 20, 20); ctx.stroke();
        ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.moveTo(14 + 5, 0); ctx.lineTo(10, -3); ctx.lineTo(10, 3); ctx.fill();
        ctx.restore();

        drawBuffFX(ctx, player);

        ctx.strokeStyle='rgba(255,255,255,0.05)'; ctx.setLineDash([5, 15]); ctx.beginPath(); ctx.arc(player.x, player.y, player.magnetRadius, 0, Math.PI*2); ctx.stroke(); ctx.setLineDash([]);
        bullets.forEach(b => { 
            ctx.shadowBlur=15; ctx.shadowColor=b.color || '#ffff00'; ctx.fillStyle= b.color || '#fff'; 
            ctx.beginPath(); ctx.arc(b.x, b.y, b.size, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur=0; 
        });
        floatingTexts.forEach(t => { ctx.fillStyle=t.color; ctx.font=`10px 'Press Start 2P'`; ctx.fillText(t.text, t.x, t.y - (40 - t.life)); });
        
        ctx.restore();
    }
    
    function loop() {
        requestAnimationFrame(loop);
        update();
        draw();
    }
    loop();
</script>
</body>
</html>